package com.example.service.implementation;import com.example.dto.StudentDto;import com.example.dto.SubjectDto;import com.example.exception.StudentNotFoundException;import com.example.exception.SubjectNotFoundException;import com.example.model.Student;import com.example.model.Subject;import com.example.model.mapper.StudentMapper;import com.example.model.mapper.SubjectMapper;import com.example.model.status.ModelStatus;import com.example.repository.StudentRepository;import com.example.repository.SubjectRepository;import com.example.service.StudentService;import com.example.service.SubjectService;import com.example.utils.MessageKey;import com.example.utils.Messages;import com.example.utils.SortingPagingUtils;import lombok.RequiredArgsConstructor;import org.mapstruct.factory.Mappers;import org.springframework.data.domain.*;import org.springframework.stereotype.Service;import java.util.Collections;import java.util.List;import java.util.Objects;import java.util.Optional;/** * Service class for Student entity. * @author Igor A. Zelaya (izelaya22@gmail.com) * @version 1.0.0 */@Service@RequiredArgsConstructorpublic class StudentServiceImpl implements StudentService {	private final StudentRepository studentRepository;	private final StudentMapper studentMapper;	private final SubjectMapper subjectMapper;	private final SubjectRepository subjectRepository;	private final SortingPagingUtils sortingPagingUtils;	private final Messages messages;	/**	 * Optional constructor for Service.	 * @param studentRepository Student Repo	 * @param subjectRepository SubjectRepo	 * @param messages Messages instance	 */	public StudentServiceImpl			(StudentRepository studentRepository, SubjectRepository subjectRepository, Messages messages,			 SortingPagingUtils sortingPagingUtils) {		this.studentRepository = studentRepository;		this.subjectRepository = subjectRepository;		this.messages = messages;		this.studentMapper = Mappers.getMapper(StudentMapper.class);		this.subjectMapper = Mappers.getMapper(SubjectMapper.class);		this.sortingPagingUtils = sortingPagingUtils;	}	@Override	public StudentDto saveStudent(final StudentDto studentDto) {		Student student = Student				.buildFromDto(this.studentMapper.dtoToStudent(studentDto));		this.studentRepository.save(student);		return studentMapper.studentToDto(student);	}	@Override	public Page<StudentDto> findPaginatedSortedStudents			(final String studentName, final int page, final int size, final String[] sort) {		//Evaluate if we should sort by two fields.		List<Sort.Order> orders = sortingPagingUtils.getSortOrders(sort);		Pageable pageable = PageRequest.of(page, size, Sort.by(orders));		List<StudentDto> studentDtos;		if(Objects.isNull(studentName)) {			studentDtos = studentMapper					.studentToDto(studentRepository.findAll(pageable).toList());		} else {			studentDtos = studentMapper					.studentToDto(studentRepository							.findByStudentNameContaining(studentName, pageable).toList());		}		return new PageImpl<>(studentDtos);	}	@Override	public StudentDto findStudentById(final String studentId, final Integer statusCode) {		Student student = studentRepository				.findByIdAndStatus(studentId, statusCode)				.orElseThrow(() -> StudentNotFoundException						.buildExceptionForId(studentId));		return studentMapper				.studentToDto(student);	}	@Override	public StudentDto findStudentByName(final String studentName, final Integer statusCode) {		Student student = studentRepository				.findByNameAndStatusContaining(studentName, statusCode)				.orElseThrow(() -> StudentNotFoundException						.buildExceptionForField("studentName", studentName));		return studentMapper				.studentToDto(student);	}	@Override	public void deleteStudentById(final String studentId){		Student student = studentMapper				.dtoToStudent(findStudentById(						studentId, ModelStatus.ACTIVE.getStatusCode()));		student.setStudentStatus(ModelStatus.INACTIVE);		studentRepository.save(student);	}	@Override	public void addSubjectToStudent			(final String studentId, final String subjectId, final SubjectDto subjectDto) {		final Student student = studentRepository				.findByIdAndStatus(studentId, ModelStatus.ACTIVE.getStatusCode())				.orElseThrow(() -> StudentNotFoundException.buildExceptionForId(studentId));		if (Objects.isNull(subjectDto)){			final Subject subject = subjectRepository					.findByIdAndStatus(subjectId, ModelStatus.ACTIVE.getStatusCode())					.orElseThrow(() -> SubjectNotFoundException.buildExceptionForId(subjectId));			student.addSubject(subject);			studentRepository.save(student);			return;		}		addSubjectToStudent(student, subjectDto);	}	private void addSubjectToStudent(final Student student, final SubjectDto subjectDto){		Subject subject = subjectMapper				.dtoToSubject(subjectDto);		student.addSubject(subject);		studentRepository.save(student);	}	@Override	public void removeSubjectFromStudent(final String studentId, final String subjectId) {		Student student = studentRepository				.findByIdAndStatus(studentId, ModelStatus.ACTIVE.getStatusCode())				.orElseThrow(() -> StudentNotFoundException.buildExceptionForId(studentId));		Subject subject = subjectRepository				.findByIdAndStatus(subjectId, ModelStatus.ACTIVE.getStatusCode())				.orElseThrow(() -> SubjectNotFoundException.buildExceptionForId(subjectId));		if(subject.getSubjectStudents().contains(student)				&& student.getStudentSubjects().contains(subject)) {			subject.getSubjectStudents().remove(student);			student.getStudentSubjects().remove(subject);			studentRepository.save(student);			return;		}		throw new IllegalArgumentException(messages				.getMessage(MessageKey.INVALID_STUDENT_SUBJECT.getKey()));	}}