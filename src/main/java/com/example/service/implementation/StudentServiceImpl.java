package com.example.service.implementation;import com.example.dto.StudentDto;import com.example.dto.SubjectDto;import com.example.exception.StudentNotFoundException;import com.example.model.Student;import com.example.model.Subject;import com.example.model.mapper.StudentMapper;import com.example.model.mapper.SubjectMapper;import com.example.model.status.ModelStatus;import com.example.repository.StudentRepository;import com.example.service.StudentService;import com.example.service.SubjectService;import com.example.utils.MessageKey;import com.example.utils.Messages;import com.example.utils.SortingPagingUtils;import lombok.RequiredArgsConstructor;import org.springframework.data.domain.*;import org.springframework.stereotype.Service;import java.util.Collections;import java.util.List;import java.util.Objects;/** * Service class for Student entity. * @author Igor A. Zelaya (izelaya22@gmail.com) * @version 1.0.0 */@Service@RequiredArgsConstructorpublic class StudentServiceImpl implements StudentService {	private final StudentRepository studentRepository;	private final StudentMapper studentMapper;	private final SubjectMapper subjectMapper;	private final SubjectService subjectService;	private final SortingPagingUtils sortingPagingUtils;	private final Messages messages;	@Override	public StudentDto saveStudent(final StudentDto studentDto) {		Student student = Student				.buildFromDto(this.studentMapper.dtoToStudent(studentDto));		this.studentRepository.save(student);		return studentMapper.studentToDto(student);	}	@Override	public Page<StudentDto> findPaginatedSortedStudents			(final String studentName, final int page, final int size, final String[] sort) {		//Evaluate if we should sort by two fields.		List<Sort.Order> orders = sortingPagingUtils.getSortOrders(sort);		Pageable pageable = PageRequest.of(page, size, Sort.by(orders));		List<StudentDto> studentDtos;		if(studentName == null) {			studentDtos = studentMapper					.studentToDto(studentRepository.findAll(pageable).toList());		} else {			studentDtos = studentMapper					.studentToDto(studentRepository							.findByStudentNameContaining(studentName, pageable).toList());		}		return new PageImpl<>(studentDtos);	}	@Override	public StudentDto findStudentById(final String studentId) {		Student student = studentRepository.findById(studentId)				.orElseThrow(() -> StudentNotFoundException						.buildStudentNotFoundExceptionForId(studentId));		return studentMapper				.studentToDto(						isActiveStudent(student, "studentId", studentId));	}	@Override	public StudentDto findStudentByName(final String studentName) {		Student student = this.studentRepository.findByStudentName(studentName)				.orElseThrow(() -> StudentNotFoundException						.buildStudentNotFoundExceptionForField("studentName", studentName));		return studentMapper				.studentToDto(						isActiveStudent(student, "studentName", studentName));	}	@Override	public void deleteStudentById(final String studentId){		Student student = studentMapper.dtoToStudent(findStudentById(studentId));		student.setStudentStatus(ModelStatus.INACTIVE);		studentRepository.save(student);	}	@Override	public void addSubjectToStudent(String studentId, SubjectDto subjectDto) {		Student student = studentMapper				.dtoToStudent(findStudentById(studentId));		Subject subject;		if(subjectService.subjectExists(subjectDto.getSubjectName())){			subject = subjectMapper					.dtoToSubject(subjectService							.findSubjectById(subjectDto.getSubjectId()));		}		else{			subject = subjectMapper					.dtoToSubject(subjectDto);		}		student.addSubject(subject);		studentRepository.save(student);	}	@Override	public void removeSubjectFromStudent(String studentId, String subjectId) {		Student student = studentMapper				.dtoToStudent(findStudentById(studentId));		Subject subject = subjectMapper				.dtoToSubject(subjectService						.findSubjectById(subjectId));		if(subject.getSubjectStudents().contains(student)				&& student.getStudentSubjects().contains(subject)){			subject.getSubjectStudents().remove(student);			student.getStudentSubjects().remove(subject);			studentRepository.save(student);			subjectService.updateSubject(subject);		}		throw new IllegalArgumentException(messages				.getMessage(MessageKey.INVALID_STUDENT_SUBJECT.getKey()));	}	/**	 * Return student if status code is ACTIVE.	 * @param student Student	 * @param queryField String	 * @param queryFieldValue String	 * @return Student	 * @throws StudentNotFoundException ex	 */	private Student isActiveStudent(Student student, String queryField, String queryFieldValue){		if(student.getStudentStatus().getStatusCode() == 0){			return student;		}		throw StudentNotFoundException				.buildStudentNotFoundExceptionForField(queryField, queryFieldValue);	}}